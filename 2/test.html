<!doctype html5>
<head>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0
        }
        canvas {
            width: 600px;
            height: 600px;
        }
    </style>
</head>
<body>
<script>

let width, height
const canvas = document.createElement('canvas')
const ctx = canvas.getContext('2d')
document.body.appendChild(canvas)
const { abs, floor, max, PI, sin } = Math
const start = Date.now()

/*
window.onresize = function () {
    width = window.innerWidth
    height = window.innerHeight
    canvas.width = width * 2
    canvas.height = height * 2
    ctx.scale(2, 2)
}
window.onresize()
*/
width = height = floor(600 / 9) * 9
canvas.width = width * 2
canvas.height = height * 2
ctx.scale(2, 2)

CanvasRenderingContext2D.prototype.fillCircle = function (centerX, centerY, radius) { this.beginPath()
    this.arc(centerX, centerY, radius, 0, 2 * Math.PI, false)
    this.fill()
}

function memoize (fn) {
    const cache = new Map()
    return function () {
        const key = Array.from(arguments).join('@')
        if (cache.has(key)) return cache.get(key)
        const returnVal = fn.apply(fn, arguments)
        cache.set(key, returnVal)
        return returnVal
    }
}
</script>
<script src="render.js"></script>
<script>
let SPACING = 9
let OFFSET = -3
let TOL = 1
let count = 0
let textData

function init () {
    ctx.save()
    ctx.fillStyle = 'black'
    ctx.globalAlpha = 0.1
    ctx.font = '120px Helvetica'
    ctx.translate(20, 20)
    ;'Aim for the impossible'.split(' ').forEach(word => {
        ctx.translate(0, 120)
        ctx.fillText(word, 0, 0)
    })
    ctx.restore()
    textData = ctx.getImageData(0, 0, canvas.width, canvas.height) 
}

const isPixelPainted = memoize((imgData, x, y) => {
    for (let i = -TOL; i <= TOL; ++i) {
        for (let j = -TOL; j <= TOL; ++j) {
            if (imgData.data[4 * ((y + i) * 2 * imgData.width + (x + j) * 2) + 3] > 0) {
                return true
            }
        }
    }
})

function joinPoints (p1, p2) {
    const offset1 = isPixelPainted(textData, p1.x, p1.y) ? OFFSET * sin(p1.x + p1.y): 0
    const offset2 = isPixelPainted(textData, p2.x, p2.y) ? OFFSET : 0
    ctx.beginPath()
    ctx.moveTo(p1.x + offset1, p1.y + offset1)
    ctx.lineTo(p2.x + offset2, p2.y + offset2)
    ctx.stroke()
}

function render () {
    ctx.fillStyle = 'white'
    ctx.fillRect(0, 0, width, height)

    for (let i = 0; i <= width / SPACING; ++i) {
        for (let j = 0; j <= height / SPACING; ++j) {
            const x = j * SPACING
            const y = i * SPACING

            ctx.strokeStyle = 'black'
            if (x > 0) joinPoints({x: (x - SPACING), y: y}, {x: x, y: y})
            if (y > 0) joinPoints({x: x, y: (y - SPACING)}, {x: x, y: y})
        }
    }
}


</script>
<script>
function loop () {
    requestAnimationFrame(loop)
    render()
}
init()
loop()

// screenshot generator
document.addEventListener('keypress', function (e) {
    console.log(e)
    if (e.code === "Space") {
        // generate "shot"
        const img = new Image()
        img.width = img.height = 600
        img.src = canvas.toDataURL()
        document.body.appendChild(img)
    }
})
</script>
</body>